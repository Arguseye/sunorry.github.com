---

layout: post
title: 预解析
categories: [learn]

---

下面是我在论坛学习的时候别人帮我解决的问题：

    function a(b) {
        alert(b);
        function b(){
          alert(b);
        };
        b();
    }
    a(1);

**首先要记住一点，函数不调用，就不会执行。**

第一次执行到：

    function a(b) {
        alert(b);
        function b(){
          alert(b);
        };
        b();
    }

这个函数时，函数里的代码是不会执行的，函数里的代码执行是在 a(1) 这个调用之后才进行的，所以正确的预解析顺序其实是这样：

1. 函数 a 被解析。
2. 执行 a(1) 调用。
3. 执行函数a 里的代码： 当函数a里面的代码还没有开始执行的时候，b 的值是传进来的参数值1。传参是优先函数里面的代码执行的。
4. 在执行函数a里面的代码之前，会先对 函数a里的函数b进行预解析，把函数b 的声明 提到 alert(b) 之前。
5. 开始执行函数a里的代码。

所有整个代码是类似于这样一个顺序来执行的：

    var a = function (b) { //第一步 ： 预解析a

        var b = 1; //第三步：传参（实际代码执行是没有这一步的，这里是为了形象地描述传参优先于预解析执行）

        b =  function b(){ //第四步：预解析b。在这一步中，因为函数的名称与形参的名称相同，所以函数会覆盖掉形参原来的值。
          alert(b);  //第七步：弹出b的值  此时b就是函数了。
        };

        alert(b); //第五步：弹出b的值

        b(); //第六步 ： 调用函数b
    }

    a(1); //第二步：调用函数a,并传参

---

    function test() {
        var a = 1;
        console.log(a);
        test2();
      }
      function test2() {
        console.log(a);
      }
      test();

>老师，这个题能拿预解析解答吗？
如果不能的话，我还是不能理解在 test 函数中调用 test2 函数，为什么它就访问不到他里面的变量。
为什么上面的函数不能写成这样。

    function test() {
        var a = 1;
        console.log(a);
        (function test2() {
          console.log(a);
        })();
      }

      test();

看来你对作用域和理解有些问题，建议多看看基础视频的作用域部分。

不论函数还是变量，都是有作用域的，而预解析只能是在同一作用域下提前解析。

你下面这段代码：

    function test() {
        var a = 1;
        console.log(a);
        test2();
      }
      function test2() {
        console.log(a);
      }
      test();

函数 test 和 函数 test2 都是全局函数。 而 变量a 在 test 函数里面，a是属于函数test里的一个局部变量。在test函数外面是访问不到里面这个变量的。test2就正好是在test外面，所以在test2里是访问不到test里面的2的。不要看test2是在函数test里调用的就以为test2是在test里面，作用域是看的函数声明或者变量所定义的位置，而不是调用它们的位置。

而下面这段代码：

    function test() {
        var a = 1;
        console.log(a);
        (function test2() {
          console.log(a);
        })();
      }

      test();

这里test2是在test里面的，test2 和 变量a 都是在test 里面的，它们是在同一个作用域下，所有在test2里可以访问到变量a。

你这两段代码所表达的意思是完全不一样的，第二段代码并非是第一段代码的改写形式。

---

腾讯的一道面试题，关于预解释的:

    var n=0;
    function a(){
      var n=10;
      function b(){
        n++;
      }
      b();
      return b;
    }
    var c=a();
    c();
    alert(n);

admin answer:

    var n=0;//全局的
    function a(){
      var n=10;//当a运行的时候，这个n属于a运行的那个作用域。（注意：一定是a方法运行的时候才会出现这个n）
      function b(){
        n++;//这个n是a运行的时候那个作用域里产生的。不会是全局的
      }
      b();
      return b;
    }
    var c=a();//c是个闭包方法，是a运行的时候返回的，这样当a运行结束的时候，这个作用域就不能被释放掉了
    c();//当c再运行的时候，会操作n,先去定义c的那个作用域里去找有没有n
    alert(n);//这里弹出的n是全局的

当方法a运行的时候，产生一个私有的作用域，这个作用域里定义了两个变量，一个是n一个是b。b是function类型的，并且b里面用到了这个n（b里没有定义n，则当这个方法运行的时候，会去找上一级作用域里定义的n。注意：变量是什么值，只和它在那儿定义的有关。）
当b运行的时候，会用到n，先会在b方法里去找n，如果找不到，则去找b定义的那个环境（b是在a里定义的），这个环境里确实定义过n，则以读或写这个，而不会影响到全局的n。

注意：当一个方法（函数）运行的时候，查找它里面使用的变量的顺序是：先找自己的作用域里有没有，如果没有，则去定义自己的那个方法里去找，如果还找不到，再按上一个原则往上找，一直找到全局里为止。如果全局里也没有这个变量，则报一个 变量未定义的错误。
方法里的变量是什么值，和这个方法在那儿运行没有关系，比如上边的c方法虽然是在全局作用域下运行的，但它不会操作全局下的变量n，因为这个方法c是在b这个方法里定义的，所以要去操作b里的n变量，如果b方法里没有，才去找全局里的变量n呢。
总结成一句话：方法里的变量是什么值，和这个方法在那儿运行没有关系，只和这个方法在那儿定义的有关系！